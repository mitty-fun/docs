---
title: 遞迴
sidebar_position: 9
---

# 遞迴

遞迴（recursion）是一種程式設計技巧，指的是在函式的定義中直接或間接地呼叫自身。
遞迴通常用於解決問題時，把問題拆解成較小的子問題，直到達到不需要再遞迴的基礎情況。
這樣的基礎情況通常能直接解決，然後逐層返回答案，形成最終結果。

## 遞迴結構

底下就是一個遞回例子，但它和無限迴圈一樣會停止不下來

```python=
def hello():
    print(1)
    hello() #執行函式自己本身
```

為了讓遞回可以結束，通常我們會設計參數傳入

```python=
def hello(x):
    print(1)
    if x > 0: hello(x - 1) #執行函式自己本身
```

幾乎所有的遞回情況，都可以用迴圈來解決，
接下來讓我們看兩個例子。

## 計算階層
計算 n!階層的定義是 `n * (n - 1) * (n - 2) ... 1`
例如 3! 階層就是 3 * 2 * 1 = 6
例如 5! 階層就是 5 * 4 * 3 * 2 * 1 = 120

使用遞迴可以這麼設計：

```python=
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
    
a = factorial(3)
b = factorial(3)
print(a, b) #就會得到 6, 120
```

同學們可以思考看看，如何在不使用遞回的情況下達到同樣的目標。

## 費式數列
費式數列的定義是每個數字是前面兩個數字的和，第一跟二的數字分別是 0, 1
數列 `0, 1, 1, 2, 3, 5, 8, 13, 21, 34...`

如果我們想知道數列第 `n` 項是多少，可以使用遞回技巧

```python=
def fibonacci(n):
    if n == 1: return 0
    if n == 2: return 1
    if n >= 3: return fibonacci(n - 1) + fibonacci(n - 2)

a = factorial(5)
b = factorial(10)
print(a, b) #就會得到 2, 34
```

同學們可以思考看看，如何在不使用遞回的情況下達到同樣的目標。


## 遞迴的應用

遞迴在許多程式設計問題中非常有用，特別是需要分解成多個子問題的情況。
例如樹結構遍尋、分治演算法、路徑搜尋、動態規劃等。

接下來我們就用數獨遊戲來做練習挑戰，
我們要使用遞回技巧來解數獨問題。

```python=
grid = [
    [0, 0, 0, 0],
    [0, 0, 1, 0],
    [0, 4, 0, 0],
    [0, 1, 0, 2]
]

def get_valid(y, x):
    h = grid[y] #水平
    v = [row[x] for row in grid] #垂直
    b = [] #區塊
    
    cy = (y // 2) * 2
    cx = (x // 2) * 2
    for xx in range(cx, cx + 2):
        for yy in range(cy, cy + 2):
            b.append(grid[yy][xx])
    
    all = h + v + b
    result = []
    for i in range(1, 5):
        if i not in all: result.append(i)

    return result

# 解一個格子的數字
# 成功解開就回傳 True
# 無法解開就回傳 False
def solve(grid):
    for y in range(4):
        for x in range(4):
            if grid[y][x] == 0:
                # 找出 y, x 個字有什麼數字可以解
                # 依序嘗試
                # # 並解下一個格子
                # # 如果下一個格子成功就回傳 True
                # 都嘗試過且不行就回傳 False
                
    return True #成功解開這個格子


print(*grid, sep="\n")
```

### 延伸挑戰 - 世紀難題
完成後挑戰改成 9 * 9 並破解史上最難的數獨題
https://www.ettoday.net/news/20120630/68551.htm

```python=
grid = [
    [8, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 3, 6, 0, 0, 0, 0, 0],
    [0, 7, 0, 0, 9, 0, 2, 0, 0],
    [0, 5, 0, 0, 0, 7, 0, 0, 0],
    [0, 0, 0, 0, 4, 5, 7, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 3, 0],
    [0, 0, 1, 0, 0, 0, 0, 6, 8],
    [0, 0, 8, 5, 0, 0, 0, 1, 0],
    [0, 9, 0, 0, 0, 0, 4, 0, 0],
]
```

### 延伸挑戰 - 數獨產生器
完成後挑戰改成數獨產生器

1. 找到一個空格
2. 產生可以填入的數字，並隨機填入一個
3. 檢查是否合法填入，不行就擦掉填下一個
4. 如果全部都不行就退回上一層遞回
5. 可以就執行遞回尋找下一個空格
6. 產生解答後先將解答印出