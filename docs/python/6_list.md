---
title: 串列
sidebar_position: 6
---

串列可以想像成一排置物櫃，每個格子都有一個編號，並且可以存放不同的資料。  
這些格子的編號從 `0` 開始，也就是第一個格子的編號是 `0`，第二個是 `1`，以此類推。

#### 為什麼需要串列？

假設老師要紀錄班上 40 位學生的成績，並計算平均、最高、最低分數等。  
在不使用串列的情況下，必須創建 40 個變數來紀錄每位學生的成績。

```python
a = 90
b = 85
c = 98
d = 76
e = 83
...
```

但如果需要紀錄全校 2000 位學生的成績，創建 2000 個變數顯然不現實。  
這時候就可以使用串列，只需要一個串列變數，就能夠輕鬆管理大量數據。

```python
scores = [90, 85, 98, 76, 83...]
```

### 如何創建串列

串列用一對中括號 `[]` 包住，裡面存放的資料用逗號 `,` 隔開。

```python
fruit = ['橘子', '蘋果', '香蕉', '芭樂', '草莓']
```

### 讀取串列

串列的每個元素可以通過編號（即索引）來讀取。注意，索引從 `0` 開始。

```python
print(fruit[0])  # 橘子
print(fruit[1])  # 蘋果
print(fruit[4])  # 草莓
print(fruit[5])  # 超出範圍，會引發錯誤
```

### 修改串列

可以直接通過編號來修改串列中的元素。

```python
fruit[2] = '芭樂'
print(fruit)    # ['橘子', '蘋果', '芭樂', '芭樂', '草莓']
print(fruit[2]) # 芭樂
```

### 新增資料

可以使用 `append` 方法將資料新增到串列的最後，或使用 `insert` 方法將資料插入到指定的位置。

```python
# 新增資料至最後
fruit.append('鳳梨')
fruit.append('芒果')
print(fruit)  # ['橘子', '蘋果', '芭樂', '芭樂', '草莓', '鳳梨', '芒果']

# 插入至指定位置（例如，插入到索引 1 的位置）
fruit.insert(1, '葡萄')
print(fruit)  # ['橘子', '葡萄', '蘋果', '芭樂', '芭樂', '草莓', '鳳梨', '芒果']
```

### 移除資料

可以使用 `pop` 方法移除串列中的資料。若不指定編號，將移除最後一個元素，也可以使用 `remove` 方法移除指定的元素。

```python
fruit = ['橘子', '蘋果', '芭樂', '芭樂', '草莓']
# 移除最後的元素
fruit.pop()     # 移除 - 草莓
# 移除編號 1 的元素 - 蘋果
fruit.pop(1)    # 移除
print(fruit)    # ['橘子', '芭樂', '芭樂']

# 移除指定的元素（例如，移除 '芭樂'）
fruit.remove('芭樂')
print(fruit)    # ['橘子', '芭樂']
```

### 計算串列長度

可以使用 `len` 函數來計算串列中目前包含的資料數量。

```python
fruit = ['橘子', '蘋果', '芭樂', '芭樂', '草莓']
print(len(fruit))  # 5
```

### 串接和複製

使用加號 `+` 可以將兩個串列串接在一起；使用乘號 `*` 則可以複製串列內容。

```python
a = ['A', 'B', 'C']
b = ['C', 'D', 'E', 'F']

print(a + b)      # ['A', 'B', 'C', 'C', 'D', 'E', 'F']
print(a * 3)      # ['A', 'B', 'C', 'A', 'B', 'C', 'A', 'B', 'C']
print(a * 2 + b)  # ['A', 'B', 'C', 'A', 'B', 'C', 'C', 'D', 'E', 'F']
```

這些操作可以讓我們靈活管理和使用大量資料，使程式更加簡潔、高效。


### 挑戰題 - 找出最陡峭的山頂

給定一個整數串列 `terrain`，每個數字代表地形的高度。
請找出「最陡峭的山頂」的索引位置。山頂的定義如下：

- 高度比左右兩側的高度都高，即「山頂」
- 左右兩側的「斜度」之和最大
- 斜度的計算方式為山頂高度與左右兩側高- 度的絕對差之和，
即 (山頂高度 - 左側高度) + (山頂高度 - 右側高度)
- 串列最前和最後因為沒有左右兩邊都有相鄰資料，因此不列入判斷

```python
terrain = [
    91, 18, 69, 29, 15, 99, 74, 44, 13, 83,
    65, 92, 97, 62, 17, 12, 16, 65, 82, 27,
    29, 16, 54, 71, 30, 66, 70, 20, 86, 40
]
```